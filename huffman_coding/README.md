# Introduction

The goal is to write code for encode and decode a given string using Huffman coding.

## Directory organization

There are two directories. 
1. `src` - contains the source code for Huffman coding
2. `test` - contains the unit test cases. 

## Execution

To execute the code from command line, following steps are needed.

1. `cd <directory where code is checked out>/huffman_coding`
2. `PYTHONPATH=src python test/test_huffman.py`


## Code design

For generating Huffman code, the algorithm relies on getting frequency count of every character. For getting and accumulating the count of each character Python dictionary data structure is used as accessing dictionary to get cumulative count for a given character is of time complexity O(1)

Next entries in dictionary is sorted and two characters of least freqency are picked up to build a binary tree with leaf nodes representing the characters and root node representing the sum of frequencies of the leaves.

Binary tree structure lends itself to recursive strategy for traversal as every node contains a value and left and right pointers pointing to child nodes at next level. Huffman code is generated by recursive travesal starting from root where every left branch is represented by `0` and right branch '1'. Binary tree is built in a way that ensures that individual character is at the leaf node. String of `0`'s and `1`'s represents encoding of every character appearing in leaf node is stored in a dictionary keyed by the character so that during encoding the completed string every character look in the string can happen with O(1) complexity.

## Efficiency

### Time efficiency

Assume the string has `n` characters. Scanning every character in the string to built frequency count will have O(1) complexity. Frequency count also requires lookup in the dictionary by key. That is also of complexity O(1)

In the next step when two chacacters of lowest frequency are picked up that requires sorting complexity O(nlogn). This process is repeated until all characters are exhausted. That increases the time complexity to ${n}^2logn$ even though the size of the array to sorted decreases by 1 for every iteration of the loop

### Space Complexity

Every recursive call require creating an entry in the stack. In a most degenerate case let us assume that one top level directory has one sub directory which has another sub directory and so on .. till the last directory which has one file. Assuming a total of n entries, number of directories + sub directories = (n - 1) That will require O(n - 1) ~ O(n) stack entries.

Similarly the accumulator to preserve all matches will require additional storage. If we assume a top level directory having (n - 1) files below it with each of them having the given suffix then the list will have size ~O(n)
